<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>Simplified Payment Verification</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="chapter_spv">Simplified Payment Verification</h2>
<div class="sectionbody">
<div class="paragraph lead">
<p>The one block header field that we didn&#8217;t investigate much in <a href="#chapter_blocks">[chapter_blocks]</a> was the Merkle root.
To understand what makes the Merkle root useful, we first have to learn about Merkle trees and what properties they have.
In this chapter, we&#8217;re going to learn exactly what a Merkle root is.
This will be motivated by something called a <em>proof of inclusion</em>.</p>
</div>
<div class="sect2">
<h3 id="_motivation">Motivation</h3>
<div class="paragraph">
<p>For a device that doesn&#8217;t have much disk space, bandwidth, or computing power, it&#8217;s expensive to store, receive, and validate the entire blockchain.
As of this writing, the entire Bitcoin blockchain is around 200 GB, which is more than many phones can store; it can be very difficult to download efficiently and will certainly tax the CPU.
If the entire blockchain cannot be put on the phone, what else can we do?
Is it possible to create a Bitcoin wallet on a phone without having all the data?</p>
</div>
<div class="paragraph">
<p>For any wallet, there are two scenarios that we&#8217;re concerned with:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Paying someone</p>
</li>
<li>
<p>Getting paid by someone</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you are paying someone with your Bitcoin wallet, it is up to the person receiving your bitcoins to verify that they&#8217;ve been paid.
Once they&#8217;ve verified that the transaction has been included in a block sufficiently deep, the other side of the trade, or the good or service, will be given to you.
Once you&#8217;ve sent the transaction to the other party, there really isn&#8217;t anything for you to do other than wait until you receive whatever it is you&#8217;re exchanging the bitcoins for.</p>
</div>
<div class="paragraph">
<p>When getting paid bitcoins, however, we have a dilemma.
If we are connected and have the full blockchain, we can easily see when the transaction is in a sufficiently deep block, at which point we give the other party our goods or services.
But if we don&#8217;t have the full blockchain, as with a phone, what can we do?</p>
</div>
<div class="paragraph">
<p>The answer lies in the Merkle root field from the block header that we saw in <a href="#chapter_blocks">[chapter_blocks]</a>.
As we saw in the last chapter, we can download the block headers and verify that they meet the Bitcoin consensus rules.
In this chapter we&#8217;re going to work toward getting proof that a particular transaction is in a block that we know about.
Since the block header is secured by proof-of-work, a transaction with a proof of inclusion in that block means, at a minimum, there was a good deal of energy spent to produce that block.
This means that the cost to deceive you would be at least the cost of the proof-of-work for the block.
The rest of this chapter goes into what the proof of inclusion is and how to verify it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_tree">Merkle Tree</h3>
<div class="paragraph">
<p>A Merkle tree is a computer science structure designed for efficient proofs of inclusion.
The prerequisites are an ordered list of items and a cryptographic hash function.
In our case, the items in the ordered list are transactions in a block and the hash function is hash256.
To construct the Merkle tree, we follow this algorithm:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hash all the items of the ordered list with the provided hash function.</p>
</li>
<li>
<p>If there is exactly 1 hash, we are done.</p>
</li>
<li>
<p>Otherwise, if there is an odd number of hashes, we duplicate the last hash in the list and add it to the end so that we have an even number of hashes.</p>
</li>
<li>
<p>We pair the hashes in order and hash the concatenation to get the parent level, which should have half the number of hashes.</p>
</li>
<li>
<p>Go to &#35;2.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The idea is to come to a single hash that "represents" the entire ordered list.
Visually, a Merkle tree looks like <a href="#merkle_tree_chap_eleven">Merkle tree</a>.</p>
</div>
<div class="paragraph">
<p>The bottom row is what we call the <em>leaves</em> of the tree.
All other nodes besides the leaves are called <em>internal nodes</em>.
The leaves get combined to produce a <em>parent level</em> (H<sub>AB</sub> and H<sub>CD</sub>), and when we calculate the parent level of that, we get the Merkle root.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll go through each part of this process in the following sections.</p>
</div>
<div id="merkle_tree_chap_eleven" class="imageblock">
<div class="content">
<img src="images/prbc_1101.png" alt="Merkle tree">
</div>
<div class="title">Figure 1. Merkle tree</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Be Careful with Merkle Trees!</div>
<div class="paragraph">
<p>There was a vulnerability in Bitcoin 0.4&#8211;0.6 related to the Merkle root, which is detailed in CVE-2012-2459.
There was a denial-of-service vector due to the duplication of the last item in Merkle trees, which caused some nodes to invalidate blocks even if they were valid.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_parent">Merkle Parent</h3>
<div class="paragraph">
<p>Given two hashes, we produce another hash that represents both of them.
As they are ordered, we will call the two hashes the <em>left</em> hash and the <em>right</em> hash.
The hash of the left and right hashes is what we call the <em>parent</em> hash.
To clarify, here&#8217;s the formula for the parent hash:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>H</em> = Hashing function</p>
</li>
<li>
<p><em>P</em> = Parent hash</p>
</li>
<li>
<p><em>L</em> = Left hash</p>
</li>
<li>
<p><em>R</em> = Right hash</p>
</li>
</ul>
</div>
<ul class="simplelist">
<li><em>P</em>=<em>H</em>(<em>L</em>||<em>R</em>)</li>
</ul>
<div class="paragraph">
<p>Note that the || symbol denotes concatenation.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how we can code this process in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt;&gt;&gt; from helper import hash256
&gt;&gt;&gt; hash0 = bytes.fromhex('c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38b\
dc15d9eb64cf5')
&gt;&gt;&gt; hash1 = bytes.fromhex('c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea\
7a08d672d7cc5')
&gt;&gt;&gt; parent = hash256(hash0 + hash1)
&gt;&gt;&gt; print(parent.hex())
8b30c5ba100f6f2e5ad1e2a742e5020491240f8eb514fe97c713c31718ad7ecd</pre>
</div>
</div>
<div class="paragraph">
<p>The reason why we hash the concatenation to get the parent is because we can provide a proof of inclusion.
Specifically, we can show that <em>L</em> is represented in the parent, <em>P</em>, by revealing <em>R</em>.
That is, if we want proof <em>L</em> is represented in <em>P</em>, the producer of <em>P</em> can show us <em>R</em> and let us know that <em>L</em> is the left child of <em>P</em>.
We can then combine <em>L</em> and <em>R</em> to produce <em>P</em> and have proof that <em>L</em> was used to produce <em>P</em>.
If <em>L</em> is not represented in <em>P</em>, being able to provide <em>R</em> would be the equivalent to providing a hash pre-image, which we know is very difficult.
This is what we mean by a proof of inclusion.</p>
</div>
<div class="sect3">
<h4 id="_exercise_1">Exercise 1</h4>
<div class="paragraph">
<p>Write the <code>merkle_parent</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_parent_level">Merkle Parent Level</h3>
<div class="paragraph">
<p>Given an ordered list of more than two hashes, we can calculate the parents of each pair, or what we call the <em>Merkle parent level</em>.
If we have an even number of hashes, this is straightforward, as we can simply pair them up in order.
If we have an odd number of hashes, then we need to do something, as we have a lone hash at the end.
We can solve this by duplicating the last item.</p>
</div>
<div class="paragraph">
<p>That is, for a list like [A, B, C] we can add C again to get [A, B, C, C].
Now we can calculate the Merkle parent of A and B and calculate the Merkle parent of C and C to get:</p>
</div>
<ul class="simplelist">
<li>[<em>H</em>(<em>A</em>||<em>B</em>), <em>H</em>(<em>C</em>||<em>C</em>)]</li>
</ul>
<div class="paragraph">
<p>Since the Merkle parent always consists of two hashes, the Merkle parent level always has exactly half the number of hashes, rounded up. Here is how we calculate a Merkle parent level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import merkle_parent
&gt;&gt;&gt; hex_hashes = [
...     'c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38bdc15d9eb64cf5',
...     'c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea7a08d672d7cc5',
...     'f391da6ecfeed1814efae39e7fcb3838ae0b02c02ae7d0a5848a66947c0727b0',
...     '3d238a92a94532b946c90e19c49351c763696cff3db400485b813aecb8a13181',
...     '10092f2633be5f3ce349bf9ddbde36caa3dd10dfa0ec8106bce23acbff637dae',
... ]
&gt;&gt;&gt; hashes = [bytes.fromhex(x) for x in hex_hashes]
&gt;&gt;&gt; if len(hashes) % 2 == 1:
...     hashes.append(hashes[-1])  # <b class="conum">(1)</b>
&gt;&gt;&gt; parent_level = []
&gt;&gt;&gt; for i in range(0, len(hashes), 2):  # <b class="conum">(2)</b>
...     parent = merkle_parent(hashes[i], hashes[i+1])
...     parent_level.append(parent)
&gt;&gt;&gt; for item in parent_level:
...     print(item.hex())
8b30c5ba100f6f2e5ad1e2a742e5020491240f8eb514fe97c713c31718ad7ecd
7f4e6f9e224e20fda0ae4c44114237f97cd35aca38d83081c9bfd41feb907800
3ecf6115380c77e8aae56660f5634982ee897351ba906a6837d15ebc3a225df0</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We add the last hash on the list, <code>hashes[-1]</code>, to the end of <code>hashes</code> to make the length of <code>hashes</code> even.</p>
</li>
<li>
<p>This is how we skip by two in Python.
<code>i</code> will be 0 the first time through the loop, 2 the second, 4 the third, and so on.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This code results in a new list of hashes that correspond to the Merkle parent level.</p>
</div>
<div class="sect3">
<h4 id="_exercise_2">Exercise 2</h4>
<div class="paragraph">
<p>Write the <code>merkle_parent_level</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_root">Merkle Root</h3>
<div class="paragraph">
<p>To get the Merkle root we calculate successive Merkle parent levels until we get a single hash.
If, for example, we have items A through G (7 items), we calculate the Merkle parent level first as follows:</p>
</div>
<ul class="simplelist">
<li>[<em>H</em>(<em>A</em>||<em>B</em>), <em>H</em>(<em>C</em>||<em>D</em>), <em>H</em>(<em>E</em>||<em>F</em>), <em>H</em>(<em>G</em>||<em>G</em>)]</li>
</ul>
<div class="paragraph">
<p>Then we calculate the Merkle parent level again:</p>
</div>
<ul class="simplelist">
<li>[<em>H</em>(<em>H</em>(<em>A</em>||<em>B</em>)||<em>H</em>(<em>C</em>||<em>D</em>)), <em>H</em>(<em>H</em>(<em>E</em>||<em>F</em>)||<em>H</em>(<em>G</em>||<em>G</em>))]</li>
</ul>
<div class="paragraph">
<p>We are left with just two items, so we calculate the Merkle parent level one more time:</p>
</div>
<ul class="simplelist">
<li><em>H</em>(<em>H</em>(<em>H</em>(<em>A</em>||<em>B</em>)||<em>H</em>(<em>C</em>||<em>D</em>))||<em>H</em>(<em>H</em>(<em>E</em>||<em>F</em>)||<em>H</em>(<em>G</em>||<em>G</em>)))</li>
</ul>
<div class="paragraph">
<p>Since we are left with exactly one hash, we are done.
Each level will halve the number of hashes, so doing this process over and over will eventually result in a final single item called the Merkle root:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; from helper import merkle_parent_level
&gt;&gt;&gt; hex_hashes = [
...     'c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38bdc15d9eb64cf5',
...     'c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea7a08d672d7cc5',
...     'f391da6ecfeed1814efae39e7fcb3838ae0b02c02ae7d0a5848a66947c0727b0',
...     '3d238a92a94532b946c90e19c49351c763696cff3db400485b813aecb8a13181',
...     '10092f2633be5f3ce349bf9ddbde36caa3dd10dfa0ec8106bce23acbff637dae',
...     '7d37b3d54fa6a64869084bfd2e831309118b9e833610e6228adacdbd1b4ba161',
...     '8118a77e542892fe15ae3fc771a4abfd2f5d5d5997544c3487ac36b5c85170fc',
...     'dff6879848c2c9b62fe652720b8df5272093acfaa45a43cdb3696fe2466a3877',
...     'b825c0745f46ac58f7d3759e6dc535a1fec7820377f24d4c2c6ad2cc55c0cb59',
...     '95513952a04bd8992721e9b7e2937f1c04ba31e0469fbe615a78197f68f52b7c',
...     '2e6d722e5e4dbdf2447ddecc9f7dabb8e299bae921c99ad5b0184cd9eb8e5908',
...     'b13a750047bc0bdceb2473e5fe488c2596d7a7124b4e716fdd29b046ef99bbf0',
... ]
&gt;&gt;&gt; hashes = [bytes.fromhex(x) for x in hex_hashes]
&gt;&gt;&gt; current_hashes = hashes
&gt;&gt;&gt; while len(current_hashes) &gt; 1:  # <b class="conum">(1)</b>
...     current_hashes = merkle_parent_level(current_hashes)
&gt;&gt;&gt; print(current_hashes[0].hex())  # <b class="conum">(2)</b>
acbcab8bcc1af95d8d563b77d24c3d19b18f1486383d75a5085c4e86c86beed6</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We loop until there&#8217;s one hash left.</p>
</li>
<li>
<p>We&#8217;ve exited the loop so there should only be one item.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_exercise_3">Exercise 3</h4>
<div class="paragraph">
<p>Write the <code>merkle_root</code> function.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_root_in_blocks">Merkle Root in Blocks</h3>
<div class="paragraph">
<p>Calculating the Merkle root in blocks should be pretty straightforward, but due to endianness issues, it turns out to be tricky.
Specifically, we use little-endian ordering for the leaves of the Merkle tree.
After we calculate the Merkle root, we use little-endian ordering again.</p>
</div>
<div class="paragraph">
<p>In practice, this means reversing the leaves before we start and reversing the root at the end:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from helper import merkle_root
&gt;&gt;&gt; tx_hex_hashes = [
...     '42f6f52f17620653dcc909e58bb352e0bd4bd1381e2955d19c00959a22122b2e',
...     '94c3af34b9667bf787e1c6a0a009201589755d01d02fe2877cc69b929d2418d4',
...     '959428d7c48113cb9149d0566bde3d46e98cf028053c522b8fa8f735241aa953',
...     'a9f27b99d5d108dede755710d4a1ffa2c74af70b4ca71726fa57d68454e609a2',
...     '62af110031e29de1efcad103b3ad4bec7bdcf6cb9c9f4afdd586981795516577',
...     '766900590ece194667e9da2984018057512887110bf54fe0aa800157aec796ba',
...     'e8270fb475763bc8d855cfe45ed98060988c1bdcad2ffc8364f783c98999a208',
... ]
&gt;&gt;&gt; tx_hashes = [bytes.fromhex(x) for x in tx_hex_hashes]
&gt;&gt;&gt; hashes = [h[::-1] for h in tx_hashes]  # <b class="conum">(1)</b>
&gt;&gt;&gt; print(merkle_root(hashes)[::-1].hex())  # <b class="conum">(2)</b>
654d6181e18e4ac4368383fdc5eead11bf138f9b7ac1e15334e4411b3c4797d9</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We reverse each hash before we begin using a Python list comprehension.</p>
</li>
<li>
<p>We reverse the root at the end.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We want to calculate Merkle roots for a <code>Block</code>, so we add a <code>tx_hashes</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Block:

    def __init__(self, version, prev_block, merkle_root,
                 timestamp, bits, nonce, tx_hashes=None):  # <b class="conum">(1)</b>
        self.version = version
        self.prev_block = prev_block
        self.merkle_root = merkle_root
        self.timestamp = timestamp
        self.bits = bits
        self.nonce = nonce
        self.tx_hashes = tx_hashes</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We now allow the transaction hashes to be set as part of the initialization of the block.
The transaction hashes have to be ordered.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As a full node, if we are given all of the transactions, we can calculate the Merkle root and check that the Merkle root is what we expect.</p>
</div>
<div class="sect3">
<h4 id="_exercise_4">Exercise 4</h4>
<div class="paragraph">
<p>Write the <code>validate_merkle_root</code> method for <code>Block</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_merkle_tree">Using a Merkle Tree</h3>
<div class="paragraph">
<p>Now that we know how a Merkle tree is constructed, we can create and verify proofs of inclusion.
Light nodes can get proofs that transactions of interest were included in a block without having to know all the transactions of a block (<a href="#merkle_proof">Merkle proof</a>).</p>
</div>
<div class="paragraph">
<p>Say that a light client has two transactions that are of interest, which would be the hashes represented by the green boxes, H<sub>K</sub> and H<sub>N</sub> in <a href="#merkle_proof">Merkle proof</a>.
A full node can construct a proof of inclusion by sending us all of the hashes marked by blue boxes: H<sub>ABCDEFGH</sub>, H<sub>IJ</sub>, H<sub>L</sub>, H<sub>M</sub>, and H<sub>OP</sub>.
The light client would then perform these calculations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>H<sub>KL</sub> = <em>merkle_parent</em>(H<sub>K</sub>, H<sub>L</sub>)</p>
</li>
<li>
<p>H<sub>MN</sub> = <em>merkle_parent</em>(H<sub>M</sub>, H<sub>N</sub>)</p>
</li>
<li>
<p>H<sub>IJKL</sub> = <em>merkle_parent</em>(H<sub>IJ</sub>, H<sub>KL</sub>)</p>
</li>
<li>
<p>H<sub>MNOP</sub> = <em>merkle_parent</em>(H<sub>MN</sub>, H<sub>OP</sub>)</p>
</li>
<li>
<p>H<sub>IJKLMNOP</sub> = <em>merkle_parent</em>(H<sub>IJKL</sub>, H<sub>MNOP</sub>)</p>
</li>
<li>
<p>H<sub>ABCDEFGHIJKLMNOP</sub> = <em>merkle_parent</em>(H<sub>ABCDEFGH</sub>, H<sub>IJKLMNOP</sub>)</p>
</li>
</ul>
</div>
<div id="merkle_proof" class="imageblock">
<div class="content">
<img src="images/prbc_1102.png" alt="Merkle Proof">
</div>
<div class="title">Figure 2. Merkle proof</div>
</div>
<div class="paragraph">
<p>You can see that in <a href="#merkle_proof">Merkle proof</a>, the dotted boxes correspond to the hashes that the light client calculates. In particular, the Merkle root is H<sub>ABCDEFGHIJKLMNOP</sub>, which can then be checked against the block header whose proof-of-work has been validated.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">How Secure Is an SPV Proof?</div>
<div class="paragraph">
<p>The full node can send a limited amount of information about the block and the light client can recalculate the Merkle root, which can then be verified against the Merkle root in the block header.
This does not guarantee that the transaction is in the longest blockchain, but it does assure the light client that the full node would have had to spend a lot of hashing power or energy creating a valid proof-of-work.
As long as the reward for creating such a proof-of-work is greater than the amounts in the transactions, the light client can at least know that the full node has no clear economic incentive to lie.</p>
</div>
<div class="paragraph">
<p>Since block headers can be requested from multiple nodes, light clients have a way to verify if one node is trying to show them block headers that are not the longest.
It only takes a single honest node to invalidate a hundred dishonest ones, since proof-of-work is objective.
Therefore, isolation of a light client (that is, control of who the light client is connected to) is required to deceive in this way.
The security of SPV requires that there be lots of honest nodes on the network.</p>
</div>
<div class="paragraph">
<p>In other words, light client security is based on a robust network of nodes and the economic cost of producing proof-of-work.
For small transactions relative to the block subsidy (currently 12.5 BTC), there&#8217;s probably little to worry about.
For large transactions (say, 100 BTC), the full nodes may have an economic incentive to deceive you.
Transactions that large should generally be validated using a full node.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merkle_block">Merkle Block</h3>
<div class="paragraph">
<p>When a full node sends a proof of inclusion, there are two pieces of information that need to be included.
First, the light client needs the Merkle tree structure, and second, the light client needs to know which hash is at which position in the Merkle tree.
Once both pieces of information are given, the light client can reconstruct the partial Merkle tree to reconstruct the Merkle root and validate the proof of inclusion.
A full node communicates these two pieces of information to a light client using a Merkle block.</p>
</div>
<div class="paragraph">
<p>To understand what&#8217;s in a Merkle block, we need to understand a bit about how a Merkle tree, or more generally, binary trees, can be traversed.
In a binary tree, nodes can be traversed breadth-first or depth-first.
Breadth-first traversal would go level by level like in <a href="#bread_first_ordering">Breadth-first ordering</a>.</p>
</div>
<div id="bread_first_ordering" class="imageblock">
<div class="content">
<img src="images/prbc_1103.png" alt="Breadth First">
</div>
<div class="title">Figure 3. Breadth-first ordering</div>
</div>
<div class="paragraph">
<p>The breadth-first ordering starts at the root and goes from root to leaves, level by level, left to right.</p>
</div>
<div class="paragraph">
<p>Depth-first ordering is a bit different and looks like <a href="#depth_first_ordering">Depth-first ordering</a>.</p>
</div>
<div id="depth_first_ordering" class="imageblock">
<div class="content">
<img src="images/prbc_1104.png" alt="Depth First">
</div>
<div class="title">Figure 4. Depth-first ordering</div>
</div>
<div class="paragraph">
<p>The depth-first ordering starts at the root and traverses the left side at each node before the right side.</p>
</div>
<div class="paragraph">
<p>In a proof of inclusion (see <a href="#merkle_proof_two">Merkle proof</a>), the full node sends the green boxes, H<sub>K</sub> and H<sub>N</sub>, along with the blue boxes, H<sub>ABCDEFGH</sub>, H<sub>IJ</sub>, H<sub>L</sub>, H<sub>M</sub> and H<sub>OP</sub>.
The location of each hash is reconstructed using depth-first ordering from some flags.
The process of reconstructing the tree, namely the dotted-edged boxes in <a href="#merkle_proof_two">Merkle proof</a>, is described next.</p>
</div>
<div id="merkle_proof_two" class="imageblock">
<div class="content">
<img src="images/prbc_1102.png" alt="Merkle proof">
</div>
<div class="title">Figure 5. Merkle proof</div>
</div>
<div class="sect3">
<h4 id="_merkle_tree_structure">Merkle Tree Structure</h4>
<div class="paragraph">
<p>The first thing a light client does is create the general structure of the Merkle tree.
Because Merkle trees are built from the leaves upward, the only thing a light client needs is the number of leaves that exist to know the structure.
The tree from <a href="#merkle_proof_two">Merkle proof</a> has 16 leaves.
A light client can create the empty Merkle tree like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">&gt;&gt;&gt; import math
&gt;&gt;&gt; total = 16
&gt;&gt;&gt; max_depth = math.ceil(math.log(total, 2))  # <b class="conum">(1)</b>
&gt;&gt;&gt; merkle_tree = []  # <b class="conum">(2)</b>
&gt;&gt;&gt; for depth in range(max_depth + 1):  # <b class="conum">(3)</b>
...     num_items = math.ceil(total / 2**(max_depth - depth))  # <b class="conum">(4)</b>
...     level_hashes = [None] * num_items  # <b class="conum">(5)</b>
...     merkle_tree.append(level_hashes)  # <b class="conum">(6)</b>
&gt;&gt;&gt; for level in merkle_tree:
...     print(level)
[None]
[None, None]
[None, None, None, None]
[None, None, None, None, None, None, None, None]
[None, None, None, None, None, None, None, None, None, None, None, None, None,\
 None, None, None]</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Since we halve at every level, log<sub>2</sub> of the number of leaves is how many levels there are in the Merkle tree.
Note we round up using <code>math.ceil</code> as we round up for halving at each level.
We could also be clever and use <code>len(bin(total))-2</code>.</p>
</li>
<li>
<p>The Merkle tree will hold the root level at index 0, the level below at index 1, and so on.
In other words, the index is the "depth" from the top.</p>
</li>
<li>
<p>There are levels 0 to <code>max_depth</code> in this Merkle tree.</p>
</li>
<li>
<p>At any particular level, the number of nodes is the number of total leaves divided by 2 for every level above the leaf level.</p>
</li>
<li>
<p>We don&#8217;t know yet what any of the hashes are, so we set them to <code>None</code>.</p>
</li>
<li>
<p>Note <code>merkle_tree</code> is a list of lists of hashes, or a two-dimensional array.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_5">Exercise 5</h4>
<div class="paragraph">
<p>Create an empty Merkle Tree with 27 items and print each level.</p>
</div>
</div>
<div class="sect3">
<h4 id="_coding_a_merkle_tree">Coding a Merkle Tree</h4>
<div class="paragraph">
<p>We can now create a <code>MerkleTree</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleTree:

    def __init__(self, total):
        self.total = total
        self.max_depth = math.ceil(math.log(self.total, 2))
        self.nodes = []
        for depth in range(self.max_depth + 1):
            num_items = math.ceil(self.total / 2**(self.max_depth - depth))
            level_hashes = [None] * num_items
            self.nodes.append(level_hashes)
        self.current_depth = 0  # <b class="conum">(1)</b>
        self.current_index = 0

    def __repr__(self):  # <b class="conum">(2)</b>
        result = []
        for depth, level in enumerate(self.nodes):
            items = []
            for index, h in enumerate(level):
                if h is None:
                    short = 'None'
                else:
                    short = '{}...'.format(h.hex()[:8])
                if depth == self.current_depth and index == self.current_index:
                    items.append('*{}*'.format(short[:-2]))
                else:
                    items.append('{}'.format(short))
            result.append(', '.join(items))
        return '\n'.join(result)</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We keep a pointer to a particular node in the tree, which will come in handy later.</p>
</li>
<li>
<p>We print a representation of the tree.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now that we have an empty tree, we can go about filling it to calculate the Merkle root.
If we had every leaf hash, getting the Merkle root would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from merkleblock import MerkleTree
&gt;&gt;&gt; from helper import merkle_parent_level
&gt;&gt;&gt; hex_hashes = [
...     "9745f7173ef14ee4155722d1cbf13304339fd00d900b759c6f9d58579b5765fb",
...     "5573c8ede34936c29cdfdfe743f7f5fdfbd4f54ba0705259e62f39917065cb9b",
...     "82a02ecbb6623b4274dfcab82b336dc017a27136e08521091e443e62582e8f05",
...     "507ccae5ed9b340363a0e6d765af148be9cb1c8766ccc922f83e4ae681658308",
...     "a7a4aec28e7162e1e9ef33dfa30f0bc0526e6cf4b11a576f6c5de58593898330",
...     "bb6267664bd833fd9fc82582853ab144fece26b7a8a5bf328f8a059445b59add",
...     "ea6d7ac1ee77fbacee58fc717b990c4fcccf1b19af43103c090f601677fd8836",
...     "457743861de496c429912558a106b810b0507975a49773228aa788df40730d41",
...     "7688029288efc9e9a0011c960a6ed9e5466581abf3e3a6c26ee317461add619a",
...     "b1ae7f15836cb2286cdd4e2c37bf9bb7da0a2846d06867a429f654b2e7f383c9",
...     "9b74f89fa3f93e71ff2c241f32945d877281a6a50a6bf94adac002980aafe5ab",
...     "b3a92b5b255019bdaf754875633c2de9fec2ab03e6b8ce669d07cb5b18804638",
...     "b5c0b915312b9bdaedd2b86aa2d0f8feffc73a2d37668fd9010179261e25e263",
...     "c9d52c5cb1e557b92c84c52e7c4bfbce859408bedffc8a5560fd6e35e10b8800",
...     "c555bc5fc3bc096df0a0c9532f07640bfb76bfe4fc1ace214b8b228a1297a4c2",
...     "f9dbfafc3af3400954975da24eb325e326960a25b87fffe23eef3e7ed2fb610e",
... ]
&gt;&gt;&gt; tree = MerkleTree(len(hex_hashes))
&gt;&gt;&gt; tree.nodes[4] = [bytes.fromhex(h) for h in hex_hashes]
&gt;&gt;&gt; tree.nodes[3] = merkle_parent_level(tree.nodes[4])
&gt;&gt;&gt; tree.nodes[2] = merkle_parent_level(tree.nodes[3])
&gt;&gt;&gt; tree.nodes[1] = merkle_parent_level(tree.nodes[2])
&gt;&gt;&gt; tree.nodes[0] = merkle_parent_level(tree.nodes[1])
&gt;&gt;&gt; print(tree)
*597c4baf.*
6382df3f..., 87cf8fa3...
3ba6c080..., 8e894862..., 7ab01bb6..., 3df760ac...
272945ec..., 9a38d037..., 4a64abd9..., ec7c95e1..., 3b67006c..., 850683df..., \
d40d268b..., 8636b7a3...
9745f717..., 5573c8ed..., 82a02ecb..., 507ccae5..., a7a4aec2..., bb626766..., \
ea6d7ac1..., 45774386..., 76880292..., b1ae7f15..., 9b74f89f..., b3a92b5b..., \
b5c0b915..., c9d52c5c..., c555bc5f..., f9dbfafc...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This fills the tree and gets us the Merkle root.
However, the message from the network may not be giving us all of the leaves.
The message might contain some internal nodes as well.
We need a cleverer way to fill the tree.</p>
</div>
<div class="paragraph">
<p><em>Tree traversal</em> is going to be the way we do this.
We can do a depth-first traversal and only fill in the nodes that we can calculate.
To traverse, we need to keep track of where exactly in the tree we are.
The properties <code>self.current_depth</code> and <code>self.current_index</code> do this.</p>
</div>
<div class="paragraph">
<p>We need methods to traverse the Merkle tree.
We&#8217;ll also include other useful methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleTree:
...
    def up(self):
        self.current_depth -= 1
        self.current_index //= 2

    def left(self):
        self.current_depth += 1
        self.current_index *= 2

    def right(self):
        self.current_depth += 1
        self.current_index = self.current_index * 2 + 1

    def root(self):
        return self.nodes[0][0]

    def set_current_node(self, value):  # <b class="conum">(1)</b>
        self.nodes[self.current_depth][self.current_index] = value

    def get_current_node(self):
        return self.nodes[self.current_depth][self.current_index]

    def get_left_node(self):
        return self.nodes[self.current_depth + 1][self.current_index * 2]

    def get_right_node(self):
        return self.nodes[self.current_depth + 1][self.current_index * 2 + 1]

    def is_leaf(self):  # <b class="conum">(2)</b>
        return self.current_depth == self.max_depth

    def right_exists(self):  # <b class="conum">(3)</b>
        return len(self.nodes[self.current_depth + 1]) &gt; \
            self.current_index * 2 + 1</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We want the ability to set the current node in the tree to some value.</p>
</li>
<li>
<p>We want to know if we are a leaf node.</p>
</li>
<li>
<p>In certain situations, we won&#8217;t have a right child because we may be at the furthest-right node of a level whose child level has an odd number of items.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We have Merkle tree traversal methods <code>left</code>, <code>right</code>, and <code>up</code>.
Let&#8217;s use these methods to populate the tree via depth-first traversal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from merkleblock import MerkleTree
&gt;&gt;&gt; from helper import merkle_parent
&gt;&gt;&gt; hex_hashes = [
...     "9745f7173ef14ee4155722d1cbf13304339fd00d900b759c6f9d58579b5765fb",
...     "5573c8ede34936c29cdfdfe743f7f5fdfbd4f54ba0705259e62f39917065cb9b",
...     "82a02ecbb6623b4274dfcab82b336dc017a27136e08521091e443e62582e8f05",
...     "507ccae5ed9b340363a0e6d765af148be9cb1c8766ccc922f83e4ae681658308",
...     "a7a4aec28e7162e1e9ef33dfa30f0bc0526e6cf4b11a576f6c5de58593898330",
...     "bb6267664bd833fd9fc82582853ab144fece26b7a8a5bf328f8a059445b59add",
...     "ea6d7ac1ee77fbacee58fc717b990c4fcccf1b19af43103c090f601677fd8836",
...     "457743861de496c429912558a106b810b0507975a49773228aa788df40730d41",
...     "7688029288efc9e9a0011c960a6ed9e5466581abf3e3a6c26ee317461add619a",
...     "b1ae7f15836cb2286cdd4e2c37bf9bb7da0a2846d06867a429f654b2e7f383c9",
...     "9b74f89fa3f93e71ff2c241f32945d877281a6a50a6bf94adac002980aafe5ab",
...     "b3a92b5b255019bdaf754875633c2de9fec2ab03e6b8ce669d07cb5b18804638",
...     "b5c0b915312b9bdaedd2b86aa2d0f8feffc73a2d37668fd9010179261e25e263",
...     "c9d52c5cb1e557b92c84c52e7c4bfbce859408bedffc8a5560fd6e35e10b8800",
...     "c555bc5fc3bc096df0a0c9532f07640bfb76bfe4fc1ace214b8b228a1297a4c2",
...     "f9dbfafc3af3400954975da24eb325e326960a25b87fffe23eef3e7ed2fb610e",
... ]
&gt;&gt;&gt; tree = MerkleTree(len(hex_hashes))
&gt;&gt;&gt; tree.nodes[4] = [bytes.fromhex(h) for h in hex_hashes]
&gt;&gt;&gt; while tree.root() is None:  # <b class="conum">(1)</b>
...     if tree.is_leaf():  # <b class="conum">(2)</b>
...         tree.up()
...     else:
...         left_hash = tree.get_left_node()
...         right_hash = tree.get_right_node()
...         if left_hash is None:  # <b class="conum">(3)</b>
...             tree.left()
...         elif right_hash is None:  # <b class="conum">(4)</b>
...             tree.right()
...         else:  # <b class="conum">(5)</b>
...             tree.set_current_node(merkle_parent(left_hash, right_hash))
...             tree.up()
&gt;&gt;&gt; print(tree)
597c4baf...
6382df3f..., 87cf8fa3...
3ba6c080..., 8e894862..., 7ab01bb6..., 3df760ac...
272945ec..., 9a38d037..., 4a64abd9..., ec7c95e1..., 3b67006c..., 850683df..., \
d40d268b..., 8636b7a3...
9745f717..., 5573c8ed..., 82a02ecb..., 507ccae5..., a7a4aec2..., bb626766..., \
ea6d7ac1..., 45774386..., 76880292..., b1ae7f15..., 9b74f89f..., b3a92b5b..., \
b5c0b915..., c9d52c5c..., c555bc5f..., f9dbfafc...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We traverse until we calculate the Merkle root.
Each time through the loop, we are at a particular node.</p>
</li>
<li>
<p>If we are at a leaf node, we already have that hash, so we don&#8217;t need to do anything but go back up.</p>
</li>
<li>
<p>If we don&#8217;t have the left hash, then we calculate the value first before calculating the current node&#8217;s hash.</p>
</li>
<li>
<p>If we don&#8217;t have the right hash, we calculate the value before calculating the current node&#8217;s hash.
Note that we already have the left one due to the depth-first traversal.</p>
</li>
<li>
<p>We have both the left and the right hash, so we calculate the Merkle parent value and set that to the current node.
Once set, we can go back up.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This code will only work when the number of leaves is a power of two, as edge cases where there are an odd number of nodes on a level are not handled.</p>
</div>
<div class="paragraph">
<p>We handle the case where the parent is the parent of the rightmost node on a level with an odd number of nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from merkleblock import MerkleTree
&gt;&gt;&gt; from helper import merkle_parent
&gt;&gt;&gt; hex_hashes = [
...     "9745f7173ef14ee4155722d1cbf13304339fd00d900b759c6f9d58579b5765fb",
...     "5573c8ede34936c29cdfdfe743f7f5fdfbd4f54ba0705259e62f39917065cb9b",
...     "82a02ecbb6623b4274dfcab82b336dc017a27136e08521091e443e62582e8f05",
...     "507ccae5ed9b340363a0e6d765af148be9cb1c8766ccc922f83e4ae681658308",
...     "a7a4aec28e7162e1e9ef33dfa30f0bc0526e6cf4b11a576f6c5de58593898330",
...     "bb6267664bd833fd9fc82582853ab144fece26b7a8a5bf328f8a059445b59add",
...     "ea6d7ac1ee77fbacee58fc717b990c4fcccf1b19af43103c090f601677fd8836",
...     "457743861de496c429912558a106b810b0507975a49773228aa788df40730d41",
...     "7688029288efc9e9a0011c960a6ed9e5466581abf3e3a6c26ee317461add619a",
...     "b1ae7f15836cb2286cdd4e2c37bf9bb7da0a2846d06867a429f654b2e7f383c9",
...     "9b74f89fa3f93e71ff2c241f32945d877281a6a50a6bf94adac002980aafe5ab",
...     "b3a92b5b255019bdaf754875633c2de9fec2ab03e6b8ce669d07cb5b18804638",
...     "b5c0b915312b9bdaedd2b86aa2d0f8feffc73a2d37668fd9010179261e25e263",
...     "c9d52c5cb1e557b92c84c52e7c4bfbce859408bedffc8a5560fd6e35e10b8800",
...     "c555bc5fc3bc096df0a0c9532f07640bfb76bfe4fc1ace214b8b228a1297a4c2",
...     "f9dbfafc3af3400954975da24eb325e326960a25b87fffe23eef3e7ed2fb610e",
...     "38faf8c811988dff0a7e6080b1771c97bcc0801c64d9068cffb85e6e7aacaf51",
... ]
&gt;&gt;&gt; tree = MerkleTree(len(hex_hashes))
&gt;&gt;&gt; tree.nodes[5] = [bytes.fromhex(h) for h in hex_hashes]
&gt;&gt;&gt; while tree.root() is None:
...     if tree.is_leaf():
...         tree.up()
...     else:
...         left_hash = tree.get_left_node()
...         if left_hash is None:  # <b class="conum">(1)</b>
...             tree.left()
...         elif tree.right_exists():  # <b class="conum">(2)</b>
...             right_hash = tree.get_right_node()
...             if right_hash is None:  # <b class="conum">(3)</b>
...                 tree.right()
...             else:  # <b class="conum">(4)</b>
...                 tree.set_current_node(merkle_parent(left_hash, right_hash))
...                 tree.up()
...         else:  # <b class="conum">(5)</b>
...             tree.set_current_node(merkle_parent(left_hash, left_hash))
...             tree.up()
&gt;&gt;&gt; print(tree)
0a313864...
597c4baf..., 6f8a8190...
6382df3f..., 87cf8fa3..., 5647f416...
3ba6c080..., 8e894862..., 7ab01bb6..., 3df760ac..., 28e93b98...
272945ec..., 9a38d037..., 4a64abd9..., ec7c95e1..., 3b67006c..., 850683df..., \
d40d268b..., 8636b7a3..., ce26d40b...
9745f717..., 5573c8ed..., 82a02ecb..., 507ccae5..., a7a4aec2..., bb626766..., \
ea6d7ac1..., 45774386..., 76880292..., b1ae7f15..., 9b74f89f..., b3a92b5b..., \
b5c0b915..., c9d52c5c..., c555bc5f..., f9dbfafc..., 38faf8c8...</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If we don&#8217;t have the left node&#8217;s value, we traverse to the left node, since all internal nodes are guaranteed a left child.</p>
</li>
<li>
<p>We check first if this node has a right child.
This is true unless this node happens to be the rightmost node and the child level has an odd number of nodes.</p>
</li>
<li>
<p>If we don&#8217;t have the right node&#8217;s value, we traverse to that node.</p>
</li>
<li>
<p>If we have both the left and the right node&#8217;s values, we calculate the current node&#8217;s value using <code>merkle_parent</code>.</p>
</li>
<li>
<p>We have the left node&#8217;s value, but the right child doesn&#8217;t exist.
This is the rightmost node of this level, so we combine the left value twice.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>We can now traverse the tree for the number of leaves that aren&#8217;t powers of two.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_merkleblock_command">The merkleblock Command</h4>
<div class="paragraph">
<p>The full node communicating a Merkle block sends all the information needed to verify that the interesting transaction is in the Merkle tree.
The <code>merkleblock</code> network command is what communicates this information; it looks like <a href="#parsed_merkleblock">Parsed merkleblock</a>.</p>
</div>
<div id="parsed_merkleblock" class="imageblock">
<div class="content">
<img src="images/prbc_1106.png" alt="merkleblock command">
</div>
<div class="title">Figure 6. Parsed merkleblock</div>
</div>
<div class="paragraph">
<p>The first six fields are exactly the same as the block header from <a href="#chapter_blocks">[chapter_blocks]</a>.
The last four fields are the proof of inclusion.</p>
</div>
<div class="paragraph">
<p>The number of transactions field indicates how many leaves this particular Merkle tree will have.
This allows a light client to construct an empty Merkle tree.
The hashes field holds the blue and green boxes from <a href="#merkle_proof_two">Merkle proof</a>.
Since the number of hashes in the hashes field is not fixed, it&#8217;s prefixed with how many there are.
Last, the flags field gives information about where the hashes go within the Merkle tree.
The flags are parsed using <code>bytes_to_bits_field</code> to convert them to a list of bits (1&#8217;s and 0&#8217;s):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def bytes_to_bit_field(some_bytes):
    flag_bits = []
    for byte in some_bytes:
        for _ in range(8):
            flag_bits.append(byte &amp; 1)
            byte &gt;&gt;= 1
    return flag_bits</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ordering for the bytes is a bit strange, but it&#8217;s meant to be easy to convert into the flag bits needed to reconstruct the Merkle root.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_6">Exercise 6</h4>
<div class="paragraph">
<p>Write the <code>parse</code> method for <code>MerkleBlock</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_flag_bits_and_hashes">Using Flag Bits and Hashes</h4>
<div class="paragraph">
<p>The flag bits inform where the hashes go using depth-first ordering.</p>
</div>
<div class="paragraph">
<p>The rules for the flag bits are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If the node&#8217;s value is given in the hashes field (blue box in <a href="#processing_a_merkle_block">Processing a Merkle block</a>), the flag bit is 0.</p>
</li>
<li>
<p>If the node is an internal node and the value is to be calculated by the light client (dotted outline in <a href="#processing_a_merkle_block">Processing a Merkle block</a>), the flag bit is 1.</p>
</li>
<li>
<p>If the node is a leaf node and is a transaction of interest (green box in <a href="#processing_a_merkle_block">Processing a Merkle block</a>), the flag is 1 and the node&#8217;s value is also given in the hashes field.
These are the items proven to be included in the Merkle tree.</p>
</li>
</ol>
</div>
<div id="processing_a_merkle_block" class="imageblock">
<div class="content">
<img src="images/prbc_1107.png" alt="Merkle Blocks and Hashes">
</div>
<div class="title">Figure 7. Processing a Merkle block</div>
</div>
<div class="paragraph">
<p>Given the tree from <a href="#processing_a_merkle_block">Processing a Merkle block</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The flag bit is 1 for the root node (1), since that hash is calculated by the light client.</p>
</li>
<li>
<p>The left child, H<sub>ABCDEFGH</sub> (2), is included in the hashes field, so the flag is 0.</p>
</li>
<li>
<p>From here, we traverse to H<sub>IJKLMNOP</sub> (3) instead of H<sub>ABCD</sub> or H<sub>EFGH</sub> since H<sub>ABCDEFGH</sub> represents both those nodes and we don&#8217;t need them.</p>
</li>
<li>
<p>The right child, H<sub>IJKLMNOP</sub>, is also calculated, so it has a flag bit of 1.</p>
</li>
<li>
<p>To calculate H<sub>IJKLMNOP</sub>, we need the values for H<sub>IJKL</sub> and H<sub>MNOP</sub> (9). The next node in depth-first order is the left child, H<sub>IJKL</sub> (4), which is where we traverse to next.</p>
</li>
<li>
<p>H<sub>IJKL</sub> is an internal node that&#8217;s calculated, so the flag bit is 1.</p>
</li>
<li>
<p>From here, we traverse to its left child, H<sub>IJ</sub> (5).
We will be traversing to H<sub>KL</sub> (6) when we come back to this node.</p>
</li>
<li>
<p>H<sub>IJ</sub> is next in depth-first ordering; its hash is included in the hashes list and the flag is 0.</p>
</li>
<li>
<p>H<sub>KL</sub> is an internal, calculated node, so the flag is 1.</p>
</li>
<li>
<p>H<sub>K</sub> (7) is a leaf node whose presence in the block is being proved, so the flag is 1.</p>
</li>
<li>
<p>H<sub>L</sub> (8) is a node whose value is included in the hashes field, so the flag is 0.</p>
</li>
<li>
<p>We traverse up to H<sub>KL</sub>, whose value can now be calculated since H<sub>K</sub> and H<sub>L</sub> are known.</p>
</li>
<li>
<p>We traverse up to H<sub>IJKL</sub>, whose value can now be calculated since H<sub>IJ</sub> and H<sub>KL</sub> are known.</p>
</li>
<li>
<p>We traverse up to H<sub>IJKLMNOP</sub>, whose value we can&#8217;t calculate yet since we haven&#8217;t been to H<sub>MNOP</sub>.</p>
</li>
<li>
<p>We traverse to H<sub>MNOP</sub>, which is another internal node, so the flag is 1.</p>
</li>
<li>
<p>H<sub>MN</sub> (10) is another internal node that&#8217;s calculated, so the flag is 1.</p>
</li>
<li>
<p>H<sub>M</sub> (11) is a node whose value is included in the hashes field, so the flag is 0.</p>
</li>
<li>
<p>H<sub>N</sub> (12) is of interest, so the flag is 1 and its value is in the hashes field.</p>
</li>
<li>
<p>We traverse up to H<sub>MN</sub>, whose value can now be calculated.</p>
</li>
<li>
<p>We traverse up again to H<sub>MNOP</sub>, whose value cannot be calculated because we haven&#8217;t been to H<sub>OP</sub> yet.</p>
</li>
<li>
<p>H<sub>OP</sub> (13) is given, so the flag is 1 and its hash is the final hash in the hashes field.</p>
</li>
<li>
<p>We traverse to H<sub>MNOP</sub>, which can now be calculated.</p>
</li>
<li>
<p>We traverse to H<sub>IJKLMNOP</sub>, which can now be calculated.</p>
</li>
<li>
<p>Finally, we traverse to H<sub>ABCDEFGHIJKLMNOP</sub>, which is the Merkle root, and calculate it!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The flag bits for nodes (1) through (13) are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>There should be seven hashes in the hashes field, in this order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>H<sub>ABCDEFGH</sub></p>
</li>
<li>
<p>H<sub>IJ</sub></p>
</li>
<li>
<p>H<sub>K</sub></p>
</li>
<li>
<p>H<sub>L</sub></p>
</li>
<li>
<p>H<sub>M</sub></p>
</li>
<li>
<p>H<sub>N</sub></p>
</li>
<li>
<p>H<sub>OP</sub></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notice that every letter is represented in the hashes, A to P.
This information is sufficient to prove that H<sub>K</sub> and H<sub>N</sub> (the green boxes in <a href="#processing_a_merkle_block">Processing a Merkle block</a>) are included in the block.</p>
</div>
<div class="paragraph">
<p>As you can see from <a href="#processing_a_merkle_block">Processing a Merkle block</a>, the flag bits are given in depth-first order.
Anytime we&#8217;re given a hash, as with H<sub>ABCDEFGH</sub>, we skip its children and continue.
In the case of H<sub>ABCDEFGH</sub>, we traverse to H<sub>IJKLMNOP</sub> instead of H<sub>ABCD</sub>.
Flag bits are a clever mechanism to encode which nodes have which hash value.</p>
</div>
<div class="paragraph">
<p>We can now populate the Merkle tree and calculate the root, given the appropriate flag bits and hashes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MerkleTree:
...
    def populate_tree(self, flag_bits, hashes):
        while self.root() is None:  # <b class="conum">(1)</b>
            if self.is_leaf():  # <b class="conum">(2)</b>
                flag_bits.pop(0)  # <b class="conum">(3)</b>
                self.set_current_node(hashes.pop(0))  # <b class="conum">(4)</b>
                self.up()
            else:
                left_hash = self.get_left_node()
                if left_hash is None:  # <b class="conum">(5)</b>
                    if flag_bits.pop(0) == 0:  # <b class="conum">(6)</b>
                        self.set_current_node(hashes.pop(0))
                        self.up()
                    else:
                        self.left()  # <b class="conum">(7)</b>
                elif self.right_exists():  # <b class="conum">(8)</b>
                    right_hash = self.get_right_node()
                    if right_hash is None:  # <b class="conum">(9)</b>
                        self.right()
                    else:  # <b class="conum">(10)</b>
                        self.set_current_node(merkle_parent(left_hash, 
                        right_hash))
                        self.up()
                else:  # <b class="conum">(11)</b>
                    self.set_current_node(merkle_parent(left_hash, left_hash))
                    self.up()
        if len(hashes) != 0:  # <b class="conum">(12)</b>
            raise RuntimeError('hashes not all consumed {}'.format(len(hashes)))
        for flag_bit in flag_bits:  # <b class="conum">(13)</b>
            if flag_bit != 0:
                raise RuntimeError('flag bits not all consumed')</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The point of populating this Merkle tree is to calculate the root.
Each loop iteration processes one node until the root is calculated.</p>
</li>
<li>
<p>For leaf nodes, we are always given the hash.</p>
</li>
<li>
<p><code>flag_bits.pop(0)</code> is a way in Python to dequeue the next flag bit.
We may want to keep track of which hashes are of interest to us by looking at the flag bit, but for now, we don&#8217;t do this.</p>
</li>
<li>
<p><code>hashes.pop(0)</code> is how we get the next hash from the hashes field.
We need to set the current node to that hash.</p>
</li>
<li>
<p>If we don&#8217;t have the left child value, there are two possibilities.
This node&#8217;s value may be in the hashes field, or it might need calculation.</p>
</li>
<li>
<p>The next flag bit tells us whether we need to calculate this node or not.
If the flag bit is 0, the next hash in the hashes field is this node&#8217;s value.
If the flag bit is 1, we need to calculate the left (and possibly the right) node&#8217;s value.</p>
</li>
<li>
<p>We are guaranteed that there&#8217;s a left child, so we traverse to that node and get its value.</p>
</li>
<li>
<p>We check that the right node exists.</p>
</li>
<li>
<p>We have the left hash, but not the right.
We traverse to the right node to get its value.</p>
</li>
<li>
<p>We have both the left and the right node&#8217;s values, so we calculate their Merkle parent to get the current node&#8217;s value.</p>
</li>
<li>
<p>We have the left node&#8217;s value, but the right does not exist.
In this case, according to Merkle tree rules, we calculate the Merkle parent of the left node twice.</p>
</li>
<li>
<p>All hashes must be consumed or we got bad data.</p>
</li>
<li>
<p>All flag bits must be consumed or we got bad data.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_exercise_7">Exercise 7</h4>
<div class="paragraph">
<p>Write the <code>is_valid</code> method for <code>MerkleBlock</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">Conclusion</h3>
<div class="paragraph">
<p>Simplified payment verification is useful but not without some significant downsides.
The full details are outside the scope of this book, but despite the programming being pretty straightforward, most light wallets do not use SPV and instead trust data from the wallet vendor servers.
The main drawback of SPV is that the nodes you are connecting to know something about the transactions you are interested in.
That is, you lose some privacy by using SPV.
This will be covered in more detail in <a href="#chapter_bloom_filters">[chapter_bloom_filters]</a> as we make Bloom filters to tell nodes what transactions we are interested in.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-11-22 19:07:17 -0600
</div>
</div>
</body>
</html>